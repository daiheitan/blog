<!DOCTYPE html>
<html>
  <head><meta name="generator" content="Hexo 3.8.0">
    <meta charset="utf-8">
    <title>Zimon Dai&#39;s Random Thoughts</title>
  </head>
  <body>
    <div class="container">
      <section id="main">
  <div class="page-title">setjmp/longjmp in Rust</div>
  <header>Posted at 2016-12-21, tagged as: 
    
      <a class="article-tag-link-link" href="/blog/tags/Rust/">Rust</a>
    .
    <a href="/blog">Go Back</a>
  </header>
  <div class="post-detail">
    <p><code>setjmp</code>/<code>longjmp</code> is used for <a href="https://en.wikipedia.org/wiki/Setjmp.h" target="_blank" rel="noopener">no-local jumps</a>, which means to ‘jump’ between different functions.</p>
<p><code>setjmp</code> is used to declare a place (which is identified by an integer id) to jump to, while <code>longjmp</code> actually jumps to a place with a <code>value</code>. Generally if <code>setjmp</code> returns an <code>value</code>, it means that a no-local jump has occurred at this place.</p>
<p>This technique is generally used for exception handling, it allows the program to kind of ‘rollback’ through the stack to some point the exception not has happened. Complex and dangerous (unexpected behaviour &amp; memory leaks) as these functions are, they are avoided mostly in modern code bases.</p>
<p>Recently I am using <a href="https://github.com/libjpeg-turbo/libjpeg-turbo" target="_blank" rel="noopener">libjpeg-turbo</a> bindings in Rust, which uses this technique for error handling. I’d like to share some experiences about dealing with libjpeg in Rust.</p>
<h2 id="Error-handling-in-Libjpeg"><a href="#Error-handling-in-Libjpeg" class="headerlink" title="Error handling in Libjpeg"></a>Error handling in Libjpeg</h2><p>Libjpeg uses a <code>jpeg_err_mgr</code> struct for error handling related stuff. The struct contains error messages, code, stack and a pointer named <code>error_exit</code> to a callback function. You could call <code>jpeg_std_err()</code> to initialize the struct.</p>
<p>If you do not assign a function to <code>error_exit</code>, libjpeg will terminate the process when error occurs. In Rust, this means the whole thread will shut down. You could use the <a href="https://doc.rust-lang.org/std/panic/fn.catch_unwind.html_" target="_blank" rel="noopener">catch_unwind</a> feature which is added to stable channel recently.</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">read_jpeg</span></span>(input_buffer: &amp;[<span class="built_in">u8</span>], target_width: <span class="built_in">u32</span>, target_height: <span class="built_in">u32</span>) -&gt; stdio::<span class="built_in">Result</span>&lt;<span class="built_in">Vec</span>&lt;<span class="built_in">u8</span>&gt;&gt; &#123;</span><br><span class="line">	catch_unwind(AssertUnwindSafe(|| &#123;</span><br><span class="line">		<span class="keyword">unsafe</span> &#123;</span><br><span class="line">			<span class="keyword">let</span> <span class="keyword">mut</span> dinfo: jpeg_decompress_struct = mem::zeroed();</span><br><span class="line">			<span class="keyword">let</span> size = mem::size_of_val(&amp;dinfo) <span class="keyword">as</span> size_t;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">let</span> <span class="keyword">mut</span> err: jpeg_error_mgr = mem::zeroed();</span><br><span class="line">			dinfo.common.err = jpeg_std_error(&amp;<span class="keyword">mut</span> err);</span><br><span class="line">			err.error_exit = <span class="literal">Some</span>(libjpeg_error_handler);</span><br><span class="line">			jpeg_CreateDecompress(&amp;<span class="keyword">mut</span> dinfo, JPEG_LIB_VERSION, size);</span><br><span class="line"></span><br><span class="line">			jpeg_mem_src(&amp;<span class="keyword">mut</span> dinfo, input_buffer.as_ptr(), input_buffer.len() <span class="keyword">as</span> <span class="built_in">u64</span>);</span><br><span class="line">			jpeg_read_header(&amp;<span class="keyword">mut</span> dinfo, <span class="literal">true</span> <span class="keyword">as</span> <span class="built_in">i32</span>);</span><br><span class="line">			<span class="keyword">let</span> image_width = dinfo.image_width;</span><br><span class="line">			<span class="keyword">let</span> image_height = dinfo.image_height;</span><br><span class="line">			<span class="keyword">if</span> target_width != image_width || target_height != image_height &#123;</span><br><span class="line">				<span class="keyword">let</span> (scale, scale_denom) = select_decompress_idct_factor(image_width, image_height, target_width, target_height);</span><br><span class="line">				dinfo.scale_num = scale;</span><br><span class="line">				dinfo.scale_denom = scale_denom;</span><br><span class="line">			&#125;</span><br><span class="line">			dinfo.dct_method = J_DCT_METHOD::JDCT_IFAST;</span><br><span class="line">			dinfo.do_fancy_upsampling = <span class="number">0</span>;</span><br><span class="line">			dinfo.two_pass_quantize = <span class="number">0</span>;</span><br><span class="line">			dinfo.dither_mode = J_DITHER_MODE::JDITHER_ORDERED;</span><br><span class="line">			jpeg_start_decompress(&amp;<span class="keyword">mut</span> dinfo);</span><br><span class="line"></span><br><span class="line">			<span class="keyword">let</span> <span class="keyword">mut</span> output_image = <span class="built_in">vec!</span>[<span class="number">0</span>; (dinfo.output_width * dinfo.output_height * <span class="number">3</span>) <span class="keyword">as</span> <span class="built_in">usize</span>];</span><br><span class="line">			<span class="keyword">let</span> output_buffer = output_image.as_mut_ptr();</span><br><span class="line">			<span class="keyword">let</span> row_stride:<span class="built_in">u64</span> = dinfo.output_width <span class="keyword">as</span> <span class="built_in">u64</span> * <span class="number">3</span>;</span><br><span class="line">			<span class="keyword">let</span> <span class="keyword">mut</span> buffer = malloc(row_stride <span class="keyword">as</span> <span class="built_in">usize</span>) <span class="keyword">as</span> *<span class="keyword">mut</span> <span class="built_in">u8</span>;</span><br><span class="line">			<span class="keyword">while</span> dinfo.output_scanline &lt; dinfo.output_height &#123;</span><br><span class="line">				jpeg_read_scanlines(&amp;<span class="keyword">mut</span> dinfo, &amp;<span class="keyword">mut</span> buffer, <span class="number">1</span>);</span><br><span class="line">				<span class="keyword">let</span> output_row = &amp;output_buffer.offset((dinfo.output_scanline <span class="keyword">as</span> <span class="built_in">isize</span> - <span class="number">1</span>) * row_stride <span class="keyword">as</span> <span class="built_in">isize</span>);</span><br><span class="line">				ptr::copy(buffer, *output_row, row_stride <span class="keyword">as</span> <span class="built_in">usize</span>);</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			jpeg_finish_decompress(&amp;<span class="keyword">mut</span> dinfo);</span><br><span class="line">			jpeg_destroy_decompress(&amp;<span class="keyword">mut</span> dinfo);</span><br><span class="line">			<span class="comment">// fclose(infile);</span></span><br><span class="line">			free(buffer <span class="keyword">as</span> *<span class="keyword">mut</span> c_void);</span><br><span class="line">			output_image.chunks(<span class="number">3</span>).collect::&lt;<span class="built_in">Vec</span>&lt;_&gt;&gt;().into_iter().flat_map(|pixel| &#123;</span><br><span class="line">                <span class="built_in">vec!</span>[pixel[<span class="number">0</span>], pixel[<span class="number">1</span>], pixel[<span class="number">2</span>], <span class="number">255</span>].into_iter()</span><br><span class="line">            &#125;).collect::&lt;<span class="built_in">Vec</span>&lt;_&gt;&gt;()</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;)).map_err(|e| &#123;</span><br><span class="line">		std::io::Error::new(std::io::ErrorKind::InvalidData, <span class="built_in">format!</span>(<span class="string">"&#123;:?&#125;"</span>, e))</span><br><span class="line">	&#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>However, <code>catch_unwind</code> will try to restore the thread with its stack, which could slow down the program. Also it’s not recommanded for a general try/catch situation. A better way is to use <code>setjmp</code>/<code>longjmp</code> in Rust FFI.</p>
<h2 id="No-local-jump-in-FFI"><a href="#No-local-jump-in-FFI" class="headerlink" title="No-local jump in FFI"></a>No-local jump in FFI</h2><p>First we should declare extern C binding for the two functions.</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> &#123;</span><br><span class="line">	<span class="function"><span class="keyword">fn</span> <span class="title">setjmp</span></span>(env: *<span class="keyword">mut</span> c_void) -&gt; c_int;</span><br><span class="line">	<span class="function"><span class="keyword">fn</span> <span class="title">longjmp</span></span>(env: *<span class="keyword">mut</span> c_void, val: c_int);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>No-local jump needs a buffer to store the stack. Create a struct to store the buffer. We will name it <code>my_error_mgr</code>. To make this easier, the struct is not handling error messages.</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[allow(non_camel_case_types)]</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">my_error_mgr</span></span> &#123;</span><br><span class="line">	<span class="keyword">pub</span> err_mgr: jpeg_error_mgr,</span><br><span class="line">	<span class="keyword">pub</span> setjmp_buffer: *<span class="keyword">mut</span> c_void</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>To use the custom error manager, we need to pass <code>my_error_mgr.err_mgr</code> to <code>jpeg_std_err</code> to initialize.</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">mut</span> setjmp_buffer: [c_int; <span class="number">27</span>] = [<span class="number">0</span>; <span class="number">27</span>];</span><br><span class="line"><span class="keyword">let</span> <span class="keyword">mut</span> my_err = my_error_mgr &#123; err_mgr: err, setjmp_buffer: mem::transmute(&amp;<span class="keyword">mut</span> setjmp_buffer) &#125;;</span><br><span class="line">dinfo.common.err = jpeg_std_error(&amp;<span class="keyword">mut</span> my_err.err_mgr);</span><br></pre></td></tr></table></figure>
<p>Next step is to create a function for error handling, bind it to the <code>err_mgr</code>. The handler will simply jump with value <code>1</code>.</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// declare the function somewhere before</span></span><br><span class="line"><span class="keyword">extern</span> <span class="string">"C"</span> <span class="function"><span class="keyword">fn</span> <span class="title">libjpeg_error_handler</span></span>(c_info: &amp;<span class="keyword">mut</span> jpeg_common_struct) &#123;</span><br><span class="line">	<span class="keyword">let</span> my_err: *<span class="keyword">mut</span> my_error_mgr = c_info.err <span class="keyword">as</span> *<span class="keyword">mut</span> my_error_mgr;</span><br><span class="line">	<span class="keyword">unsafe</span> &#123; longjmp((*my_err).setjmp_buffer, <span class="number">1</span>); &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">my_err.err_mgr.error_exit = <span class="literal">Some</span>(libjpeg_error_handler);</span><br></pre></td></tr></table></figure>
<p>we will check <code>setjmp</code> before the decoding process begins, if an expection did occur, return an <code>Err</code> and prevent the crash.</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> setjmp(my_err.setjmp_buffer) != <span class="number">0</span> &#123;</span><br><span class="line">    jpeg_destroy_decompress(&amp;<span class="keyword">mut</span> dinfo);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">Err</span>(std::io::Error::new(std::io::ErrorKind::InvalidData, <span class="string">"jpeg decode error"</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>The complete example:</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="string">"C"</span> <span class="function"><span class="keyword">fn</span> <span class="title">libjpeg_error_handler</span></span>(c_info: &amp;<span class="keyword">mut</span> jpeg_common_struct) &#123;</span><br><span class="line">	<span class="keyword">let</span> my_err: *<span class="keyword">mut</span> my_error_mgr = c_info.err <span class="keyword">as</span> *<span class="keyword">mut</span> my_error_mgr;</span><br><span class="line">	<span class="keyword">unsafe</span> &#123; longjmp((*my_err).setjmp_buffer, <span class="number">1</span>); &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#[allow(non_camel_case_types)]</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">my_error_mgr</span></span> &#123;</span><br><span class="line">	<span class="keyword">pub</span> err_mgr: jpeg_error_mgr,</span><br><span class="line">	<span class="keyword">pub</span> setjmp_buffer: *<span class="keyword">mut</span> c_void</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">extern</span> &#123;</span><br><span class="line">	<span class="function"><span class="keyword">fn</span> <span class="title">setjmp</span></span>(env: *<span class="keyword">mut</span> c_void) -&gt; c_int;</span><br><span class="line">	<span class="function"><span class="keyword">fn</span> <span class="title">longjmp</span></span>(env: *<span class="keyword">mut</span> c_void, val: c_int);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">read_jpeg</span></span>(input_buffer: &amp;[<span class="built_in">u8</span>], target_width: <span class="built_in">u32</span>, target_height: <span class="built_in">u32</span>) -&gt; stdio::<span class="built_in">Result</span>&lt;<span class="built_in">Vec</span>&lt;<span class="built_in">u8</span>&gt;&gt; &#123;</span><br><span class="line">	<span class="keyword">unsafe</span> &#123;</span><br><span class="line">		<span class="keyword">let</span> <span class="keyword">mut</span> dinfo: jpeg_decompress_struct = mem::zeroed();</span><br><span class="line">		<span class="keyword">let</span> size = mem::size_of_val(&amp;dinfo) <span class="keyword">as</span> size_t;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">let</span> <span class="keyword">mut</span> err: jpeg_error_mgr = mem::zeroed();</span><br><span class="line">		<span class="keyword">let</span> <span class="keyword">mut</span> setjmp_buffer: [c_int; <span class="number">27</span>] = [<span class="number">0</span>; <span class="number">27</span>];</span><br><span class="line">		<span class="keyword">let</span> <span class="keyword">mut</span> my_err = my_error_mgr &#123; err_mgr: err, setjmp_buffer: mem::transmute(&amp;<span class="keyword">mut</span> setjmp_buffer) &#125;;</span><br><span class="line">		dinfo.common.err = jpeg_std_error(&amp;<span class="keyword">mut</span> my_err.err_mgr);</span><br><span class="line">		my_err.err_mgr.error_exit = <span class="literal">Some</span>(libjpeg_error_handler);</span><br><span class="line">		<span class="keyword">if</span> setjmp(my_err.setjmp_buffer) != <span class="number">0</span> &#123;</span><br><span class="line">			jpeg_destroy_decompress(&amp;<span class="keyword">mut</span> dinfo);</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">Err</span>(stdio::Error::new(stdio::ErrorKind::InvalidData, <span class="string">"jpeg decode error"</span>));</span><br><span class="line">		&#125;</span><br><span class="line">		jpeg_CreateDecompress(&amp;<span class="keyword">mut</span> dinfo, JPEG_LIB_VERSION, size);</span><br><span class="line">		jpeg_mem_src(&amp;<span class="keyword">mut</span> dinfo, input_buffer.as_ptr(), input_buffer.len() <span class="keyword">as</span> <span class="built_in">u64</span>);</span><br><span class="line">		jpeg_read_header(&amp;<span class="keyword">mut</span> dinfo, <span class="literal">true</span> <span class="keyword">as</span> <span class="built_in">i32</span>);</span><br><span class="line">		<span class="keyword">let</span> image_width = dinfo.image_width;</span><br><span class="line">		<span class="keyword">let</span> image_height = dinfo.image_height;</span><br><span class="line">		<span class="keyword">if</span> target_width != image_width || target_height != image_height &#123;</span><br><span class="line">			<span class="keyword">let</span> (scale, scale_denom) = select_decompress_idct_factor(image_width, image_height, target_width, target_height);</span><br><span class="line">			dinfo.scale_num = scale;</span><br><span class="line">			dinfo.scale_denom = scale_denom;</span><br><span class="line">		&#125;</span><br><span class="line">		dinfo.dct_method = J_DCT_METHOD::JDCT_IFAST;</span><br><span class="line">		dinfo.do_fancy_upsampling = <span class="number">0</span>;</span><br><span class="line">		dinfo.two_pass_quantize = <span class="number">0</span>;</span><br><span class="line">		dinfo.dither_mode = J_DITHER_MODE::JDITHER_ORDERED;</span><br><span class="line">		jpeg_start_decompress(&amp;<span class="keyword">mut</span> dinfo);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">let</span> <span class="keyword">mut</span> output_image = <span class="built_in">vec!</span>[<span class="number">0</span>; (dinfo.output_width * dinfo.output_height * <span class="number">3</span>) <span class="keyword">as</span> <span class="built_in">usize</span>];</span><br><span class="line">		<span class="keyword">let</span> output_buffer = output_image.as_mut_ptr();</span><br><span class="line">		<span class="keyword">let</span> row_stride:<span class="built_in">u64</span> = dinfo.output_width <span class="keyword">as</span> <span class="built_in">u64</span> * <span class="number">3</span>;</span><br><span class="line">		<span class="keyword">let</span> <span class="keyword">mut</span> buffer = malloc(row_stride <span class="keyword">as</span> <span class="built_in">usize</span>) <span class="keyword">as</span> *<span class="keyword">mut</span> <span class="built_in">u8</span>;</span><br><span class="line">		<span class="keyword">while</span> dinfo.output_scanline &lt; dinfo.output_height &#123;</span><br><span class="line">			jpeg_read_scanlines(&amp;<span class="keyword">mut</span> dinfo, &amp;<span class="keyword">mut</span> buffer, <span class="number">1</span>);</span><br><span class="line">			<span class="keyword">let</span> output_row = &amp;output_buffer.offset((dinfo.output_scanline <span class="keyword">as</span> <span class="built_in">isize</span> - <span class="number">1</span>) * row_stride <span class="keyword">as</span> <span class="built_in">isize</span>);</span><br><span class="line">			ptr::copy(buffer, *output_row, row_stride <span class="keyword">as</span> <span class="built_in">usize</span>);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		jpeg_finish_decompress(&amp;<span class="keyword">mut</span> dinfo);</span><br><span class="line">		jpeg_destroy_decompress(&amp;<span class="keyword">mut</span> dinfo);</span><br><span class="line">		<span class="comment">// fclose(infile);</span></span><br><span class="line">		free(buffer <span class="keyword">as</span> *<span class="keyword">mut</span> c_void);</span><br><span class="line">		<span class="keyword">let</span> alpha = &amp;[<span class="number">255</span>];</span><br><span class="line">		<span class="keyword">let</span> output_image = output_image.chunks(<span class="number">3</span>).flat_map(|chunk| &#123;</span><br><span class="line">			chunk.into_iter().chain(alpha)</span><br><span class="line">		&#125;).map(|i| *i).collect::&lt;<span class="built_in">Vec</span>&lt;_&gt;&gt;();</span><br><span class="line">        <span class="literal">Ok</span>(output_image)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
  </div>
</section>
    </div>
    <footer class="footer">
  <div class="theme-changer">
    You are currently using the <span id="theme-indicator">light</span> theme, <a id="theme-change-button">[change]</a>. The color scheme is from the <a href="https://github.com/dracula/dracula-theme" target="_blank">[dracula theme]</a>
    <p>Suscribe this blog, click <a href="/blog/atom.xml">here</a></p>
  </div>
  <link rel="stylesheet" href="/blog/css/style.css">
  <script src="/blog/js/script.js"></script>
  <link rel="stylesheet" href="/blog/css/fira.css">
</footer>
  </body>
</html>